private ulong GenerateAttacks(Board board, King opponentKing, ulong opponentKingBitboard, int direction, ulong teamPiecesBitboard, ulong opponentPiecesBitboard, ulong teamPawnBitboard, ulong opponentPawnBitboard, ulong allPiecesBitboard) {
    int numSquaresToEdge = Board.NumSquaresToEdgeFromSquare(squareIndex, direction);
    if (numSquaresToEdge == 0)
        // there are no attacks to add in this direction since the piece is on the edge of the board
        return 0;

    ulong initialAttacks = BitboardHelper.GetAttackBitboard(squareIndex, direction);
    // remove the attackers square index
    initialAttacks ^= 1ul << squareIndex;

    // there's no pieces blocking in this direction so can return the initial attackBitboard
    if ((allPiecesBitboard & initialAttacks) == 0) {
        return initialAttacks;
    }
    
    int blockerSquareIndex = 0;
    switch (direction) {
        case < 0:
            // pop most significant bit to get the piece closest to the attacker
            ulong blockersInAttackLine = initialAttacks & allPiecesBitboard;
            blockerSquareIndex = BitboardHelper.PopMostSignificantBit(ref blockersInAttackLine);
            break;
        case > 0:
            // pop least significant bit to get the piece closest to the attacker
            blockersInAttackLine = initialAttacks & allPiecesBitboard;
            blockerSquareIndex = BitboardHelper.PopLeastSignificantBit(ref blockersInAttackLine);
            break;
    }
    
    (int blockerX, int blockerY) = Board.ConvertSquareIndexToCoord(blockerSquareIndex);
    ulong attacksRegardingBlockingPieces = initialAttacks;
    switch (direction) {
        case CompassDirections.Right:
                if (blockerY == 0 || blockerY == 8 - 1) {
                return initialAttacks;
            }
            int offset = 8 - 1 - blockerX;
            attacksRegardingBlockingPieces >>= offset;
            attacksRegardingBlockingPieces &= initialAttacks;
            break;
        case CompassDirections.Left:
            if (blockerY == 0 || blockerY == 8 - 1) {
                return initialAttacks;
            }
            offset = blockerX;
            attacksRegardingBlockingPieces <<= offset;
            attacksRegardingBlockingPieces &= initialAttacks;
            // BitboardHelper.PrintBitboard(attacksRegardingBlockingPieces, 8);
            break;
        case CompassDirections.Up:
            if (blockerX == 0 || blockerX == 8 - 1) {
                return initialAttacks;
            }
            offset = 8 - 1 - blockerY;
            attacksRegardingBlockingPieces >>= offset * 8;
            attacksRegardingBlockingPieces &= initialAttacks;
            break;
        case CompassDirections.Down:
            if (blockerX == 0 || blockerX == 8 - 1) {
                return initialAttacks;
            }
            offset = blockerY;
            attacksRegardingBlockingPieces <<= offset * 8;
            attacksRegardingBlockingPieces &= initialAttacks;
            break;
        // don't even ask me why the right diagonals only use the y coordinate and the left diagonals only use the x coordinate
        // because I have no idea
        case CompassDirections.TopRight:
            if (blockerX == 0 || blockerX == 8 - 1 || blockerY == 0 || blockerY == 8 - 1) {
                return initialAttacks;
            }
            offset = 8 - 1 - blockerY;
            // offsetting the bitboard by the offset on the y-axis so have to multiply by 8
            attacksRegardingBlockingPieces >>= offset * 8;
            // ofsetting the bitboard by the offset on the x-axis
            attacksRegardingBlockingPieces >>= offset;
            attacksRegardingBlockingPieces &= initialAttacks;
            break;
        case CompassDirections.BottomLeft:
            if (blockerX == 0 || blockerX == 8 - 1 || blockerY == 0 || blockerY == 8 - 1) {
                return initialAttacks;
            }
            offset = blockerX;
            attacksRegardingBlockingPieces <<= offset * 8;
            attacksRegardingBlockingPieces <<= offset;
            attacksRegardingBlockingPieces &= initialAttacks;
            break;
        case CompassDirections.TopLeft:
            if (blockerX == 0 || blockerX == 8 - 1 || blockerY == 0 || blockerY == 8 - 1) {
                return initialAttacks;
            }
            offset = blockerX;
            attacksRegardingBlockingPieces >>= offset * 8;
            attacksRegardingBlockingPieces <<= offset;
            attacksRegardingBlockingPieces &= initialAttacks;
            break;
        case CompassDirections.BottomRight:
            if (blockerX == 0 || blockerX == 8 - 1 || blockerY == 0 || blockerY == 8 - 1) {
                return initialAttacks;
            }
            offset = blockerY;
            attacksRegardingBlockingPieces <<= offset * 8;
            attacksRegardingBlockingPieces >>= offset;
            attacksRegardingBlockingPieces &= initialAttacks;
            break;
    }

    // there's a piece in the way but there's no opponent king in the direction so don't need
    // to check for pins or checks
    if ((initialAttacks & opponentKingBitboard) == 0) {
        return attacksRegardingBlockingPieces;
    }
    ulong spacesAfterLegalAttacks = initialAttacks ^ attacksRegardingBlockingPieces;
    ulong pieceSquareMask = 1ul << blockerSquareIndex;

    // check the king
    if (blockerSquareIndex == opponentKing.squareIndex) {
        ulong checkLine = attacksRegardingBlockingPieces;
        // removing the king square and adding the queen square
        BitboardHelper.RemoveSquareFromBitboard(ref checkLine, blockerSquareIndex);
        BitboardHelper.AddSquare(ref checkLine, squareIndex);
        opponentKing.Check(checkLine);
    }
    // checking whether to restrict en passant
    else if (NeedsToCheckRestrictionOfEnPassant(board, direction, blockerSquareIndex, teamPawnBitboard, opponentPawnBitboard)) {
        ulong spacesBetweenSecondPawnAndKing = spacesAfterLegalAttacks;

        // removing the second pawn and the king from the bitboard
        BitboardHelper.RemoveSquareFromBitboard(ref spacesBetweenSecondPawnAndKing, blockerSquareIndex + direction);
        BitboardHelper.RemoveSquareFromBitboard(ref spacesBetweenSecondPawnAndKing, opponentKing.squareIndex);
        // there's either no space or there's empty space between the two pawns and the opponent king
        if (spacesBetweenSecondPawnAndKing == 0 || (allPiecesBitboard & spacesBetweenSecondPawnAndKing) == 0) {
            // the first pawn is the team's en passant pawn so the opponent
            // piece is on the second square in the direction and so needs it en passant capture restricting
            if ((teamPiecesBitboard & pieceSquareMask) != 0) {
                if (board.pieces[blockerSquareIndex + direction] is Pawn pawn) {
                    // Console.WriteLine("Restricting second pawn's en passant");
                    pawn.enPassantIsLegal = false;
                }
            }
            // the second pawn is the team's en passant pawn so the opponent
            // piece is on the first square in the direction and so needs it en passant capture restricting
            else if ((teamPiecesBitboard & (1ul << (blockerSquareIndex + direction))) != 0) {
                if (board.pieces[blockerSquareIndex] is Pawn pawn) {
                    // Console.WriteLine("Restricting first pawn's en passant");
                    pawn.enPassantIsLegal = false;
                }
            }
        }
    }
    // the piece is in the opponents bitboard so may need pinning
    else if ((opponentPiecesBitboard & pieceSquareMask) != 0) {
        ulong squaresBetweenPieceAndKing = spacesAfterLegalAttacks;
        // remove the king square and the potentially pinned piece square to get the squares between them
        BitboardHelper.RemoveSquareFromBitboard(ref squaresBetweenPieceAndKing, opponentKing.squareIndex);
        
        // if there's no space or there's empty space between the piece and the king, then the piece is pinned
        if (squaresBetweenPieceAndKing == 0 || (allPiecesBitboard & squaresBetweenPieceAndKing) == 0) {
            ulong pinnedLine = attacksRegardingBlockingPieces;
            // remove the pinned piece square and add the attacking square
            BitboardHelper.RemoveSquareFromBitboard(ref pinnedLine, blockerSquareIndex);
            BitboardHelper.AddSquare(ref pinnedLine, squareIndex);
            board.pieces[blockerSquareIndex].Pin(pinnedLine);
        }
    }

    return attacksRegardingBlockingPieces;
}