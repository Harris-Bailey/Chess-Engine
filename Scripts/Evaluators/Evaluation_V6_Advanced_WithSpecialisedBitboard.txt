namespace Chess_Application;

public class Evaluation_V6_Advanced : IEvaluation {
    public int pawnValue { get; set; } = 100;
    public int knightValue { get; set; } = 325;
    public int bishopValue { get; set; } = 340;
    public int rookValue { get; set; } = 500;
    public int queenValue { get; set; } = 900;
    
    private Bitboard fileMask = new Bitboard(0b0000000100000001000000010000000100000001000000010000000100000001);
    private Bitboard[] fileMasks;
    
    IPositionTables positionTables;
    
    public Evaluation_V6_Advanced(IPositionTables positionTables) {
        this.positionTables = positionTables;
        
        fileMasks = new Bitboard[8];
        for (int i = 0; i < 8; i++) {
            fileMasks[i] = Bitboard.LeftShift(fileMask, i);
        }
    }

    public int Evaluate(Board board, Team team, Team opposingTeam) {
        int score = 0;
        
        Bitboard teamPawnBitboard = new Bitboard(board.GetPieceBitboard<Pawn>(team));
        Bitboard teamBishopBitboard = new Bitboard(board.GetPieceBitboard<Bishop>(team));
        Bitboard teamKnightBitboard = new Bitboard(board.GetPieceBitboard<Knight>(team));
        Bitboard teamRookBitboard = new Bitboard(board.GetPieceBitboard<Rook>(team));
        Bitboard teamQueenBitboard = new Bitboard(board.GetPieceBitboard<Queen>(team));
        Bitboard teamKingBitboard = new Bitboard(board.GetPieceBitboard<King>(team));
        
        Bitboard opponentsPieces = new Bitboard(board.GetTeamBitboard(opposingTeam));
        Bitboard opponentPawnBitboard = new Bitboard(board.GetPieceBitboard<Pawn>(opposingTeam));
        Bitboard opponentPiecesWithoutPawns = Bitboard.ExclusiveOr(opponentsPieces, opponentPawnBitboard);
        
        int numTeamPawns = teamPawnBitboard.GetPieceCount();
        int numTeamBishops = teamBishopBitboard.GetPieceCount();
        int numTeamKnights = teamKnightBitboard.GetPieceCount();
        int numTeamRooks = teamRookBitboard.GetPieceCount();
        int numTeamQueens = teamQueenBitboard.GetPieceCount();
        
        score += numTeamPawns * pawnValue;
        score += numTeamBishops * bishopValue;
        score += numTeamKnights * knightValue;
        score += numTeamRooks * rookValue;
        score += numTeamQueens * queenValue;
        
        if (team == Team.White) {
            score += GetPositionValues(teamPawnBitboard, positionTables.WhitePawnPositionTable);
            score += GetPositionValues(teamBishopBitboard, positionTables.WhiteBishopPositionTable);
            score += GetPositionValues(teamKnightBitboard, positionTables.WhiteKnightPositionTable);
            score += GetPositionValues(teamRookBitboard, positionTables.WhiteRookPositionTable);
            score += GetPositionValues(teamQueenBitboard, positionTables.WhiteQueenPositionTable);
            score += GetPositionValues(teamKingBitboard, positionTables.WhiteKingPositionTable);
        }
        else if (team == Team.Black) {
            score += GetPositionValues(teamPawnBitboard, positionTables.BlackPawnPositionTable);
            score += GetPositionValues(teamBishopBitboard, positionTables.BlackBishopPositionTable);
            score += GetPositionValues(teamKnightBitboard, positionTables.BlackKnightPositionTable);
            score += GetPositionValues(teamRookBitboard, positionTables.BlackRookPositionTable);
            score += GetPositionValues(teamQueenBitboard, positionTables.BlackQueenPositionTable);
            score += GetPositionValues(teamKingBitboard, positionTables.BlackKingPositionTable);
        }
        
        // go through every rank / file
        for (int i = 0; i < Board.dimensions; i++) {            
            int numPawnsOnFile = teamPawnBitboard.GetPieceCount(fileMasks[i]);
            if (numPawnsOnFile > 0) {
                score += GetPawnScore(board, teamPawnBitboard, opponentPiecesWithoutPawns, opponentPawnBitboard, numPawnsOnFile, i);
            }

            // handle reward for rooks being on the same rank
            int numRooksOnFile = teamRookBitboard.GetPieceCount(fileMasks[i]);
            if (numRooksOnFile > 0) {
                score += GetRookScore(numRooksOnFile, numPawnsOnFile);
            }
        }

        score += GetBishopScore(teamBishopBitboard, Bitboard.Or(teamPawnBitboard, opponentPawnBitboard), numTeamBishops);

        if (board.GetTeamsKing(opposingTeam).isChecked) {
            score += 10;
        }
        
        return score;
    }
    
    private int GetPositionValues(Bitboard bitboard, int[] positionValues) {
        int score = 0;
        Bitboard bitboardCopy = new Bitboard(bitboard);
        while (!bitboardCopy.IsEmpty) {
            int squareIndex = bitboardCopy.PopLeastSignificantBit();
            score += positionValues[squareIndex];
        }
        return score;
    }
    
    public int GetPawnScore(Board board, Bitboard teamPawnBitboard, Bitboard opponentBitboardWithoutPawns, Bitboard opponentPawnBitboard, int numPawnsOnFile, int fileIndex) {
        int score = 0;
        // doubled pawns
        if (numPawnsOnFile > 1) {
            int stackedPawnPenalty = 7;
            // the more pawns on the same file, the more penalty
            score -= stackedPawnPenalty * numPawnsOnFile;
        }

        // the surrounding files of the current file, including the current file
        // for example the file may be file C and then the mask will include file B, C, and D
        Bitboard surroundingFilesMask = new Bitboard(fileMask);
        bool hasPawnOnLeftFile = false;
        bool hasPawnOnRightFile = false;
        if (fileIndex > 0) {
            Bitboard fileMaskOnLeft = fileMasks[fileIndex - 1];
            hasPawnOnLeftFile = teamPawnBitboard.ContainsAny(fileMaskOnLeft);
            surroundingFilesMask.Or(fileMaskOnLeft);
        }
        if (fileIndex < Board.dimensions - 1) {
            Bitboard fileMaskOnRight = fileMasks[fileIndex + 1];
            hasPawnOnRightFile = teamPawnBitboard.ContainsAny(fileMaskOnRight);
            surroundingFilesMask.Or(fileMaskOnRight);
        }

        // subtract the score if the pawn is isolated
        if (!hasPawnOnLeftFile && !hasPawnOnRightFile) {
            int pawnIsolationPenalty = 2;
            score -= pawnIsolationPenalty;
        }
        
        Bitboard teamPawnsInFileMask = Bitboard.And(teamPawnBitboard, fileMask);
        while (!teamPawnsInFileMask.IsEmpty) {
            int pawnSquareIndex = teamPawnsInFileMask.PopLeastSignificantBit();
            if (board.pieces[pawnSquareIndex] is not Pawn pawn) {
                // if everything runs correctly, then this should never get executed
                Console.WriteLine("Why is there a different piece in the pawn bitboard?");
                Console.WriteLine("This is being printed from Evaluation_V6_Evaluation on line 148!");
                Environment.Exit(0);
                return 0;
            }
            Pawn.MovementDirection direction = pawn.direction;
            (_, int pawnYIndex) = Board.ConvertSquareIndexToCoord(pawnSquareIndex);
            // this section offsets the file mask so that instead of it being the whole file, it just keeps the squares infront of the pawn
            // if it's the en passant pawn though, then we have to include the rank of the pawn because it can be captured on that rank
            // e.g. assuming this is an upwards moving pawn:
            /*  surrounding file mask       pawn position       resulting file mask     resulting file mask for en passant pawn
                        1 1 1                   0 0 0               1 1 1                           1 1 1
                        1 1 1                   0 0 0               1 1 1                           1 1 1
                        1 1 1                   0 1 0               0 0 0                           1 1 1
                        1 1 1                   0 0 0               0 0 0                           0 0 0
                        1 1 1                   0 0 0               0 0 0                           0 0 0
                        1 1 1                   0 0 0               0 0 0                           0 0 0
                        1 1 1                   0 0 0               0 0 0                           0 0 0
                        1 1 1                   0 0 0               0 0 0                           0 0 0
            */
            // and for black it'd just select the squares below the pawn
            bool pawnIsEnPassantPawn = board.PreviousStateAvailable && pawn == board.gameStates.Peek().pawnCapturableByEnPassant;
            int passedPawnRewardPerRank = 10;
            int totalRewardForPassedPawn = 0;
            int hostilePieceBlockingPassedPawnPenalty = 5;
            int totalPenaltyForHostileBlocker = 0;
            if (direction == Pawn.MovementDirection.MovingUpwards) {
                int rankToShiftTo = pawnIsEnPassantPawn ? pawnYIndex : pawnYIndex + 1;
                surroundingFilesMask.LeftShift(rankToShiftTo * Board.dimensions);

                // if the pawn is moving upwards and is on a higher rank, the higher the reward is
                totalRewardForPassedPawn = passedPawnRewardPerRank * (pawnYIndex + 1);
                
                // if the pawn is moving upwards and is on a higher rank, the more valuable the passed pawn is
                totalPenaltyForHostileBlocker = hostilePieceBlockingPassedPawnPenalty * (pawnYIndex + 1);
            }
            else if (direction == Pawn.MovementDirection.MovingDownwards) {
                int rankToShiftTo = pawnIsEnPassantPawn ? Board.dimensions - (pawnYIndex + 1) : Board.dimensions - pawnYIndex;
                surroundingFilesMask.RightShift(rankToShiftTo * Board.dimensions);
                
                // if the pawn is moving downwards and is on a lower rank, the higher the reward is
                totalRewardForPassedPawn = passedPawnRewardPerRank * (7 - pawnYIndex + 1);
                
                // if the pawn is moving downwards and is on a lower rank, the more valuable the passed pawn is
                totalPenaltyForHostileBlocker = hostilePieceBlockingPassedPawnPenalty * (7 - pawnYIndex + 1);
            }
            // checking whether there are any opponent pawns in the mask since that would mean the pawn isn't a passed pawn
            if (surroundingFilesMask.ContainsAny(opponentPawnBitboard)) {
                continue;
            }
            // no opponent pawns in the surrounding file mask so can give the position a reward
            score += totalRewardForPassedPawn;

            // checking if there's any hostile pieces infront of a passed pawn
            Bitboard fileBitboardInfrontOfPawn = Bitboard.And(surroundingFilesMask, fileMask);
            bool otherOpponentPiecesOnFile = fileBitboardInfrontOfPawn.ContainsAny(opponentBitboardWithoutPawns);
            // this section might make the engine think that simply putting a teams piece infront of the pawn is more beneficial
            // so maybe change this to check whether the pawn is protected? I'm not sure about this yet though
            if (otherOpponentPiecesOnFile) {
                score -= totalPenaltyForHostileBlocker;
            }
        }
        return score;
    }
    
    private int GetBishopScore(Bitboard teamBishopBitboard, Bitboard allPawnsBitboard, int bishopCount) {
        int score = 0;
        score += bishopCount >= 2 ? 50 : 0;
        int pawnOnAdjacentSquarePenalty = 20;
        Bitboard diagonalSquareMask = new Bitboard();
        Bitboard bishopBitboardCopy = new Bitboard(teamBishopBitboard);
        while (!bishopBitboardCopy.IsEmpty) {
            int squareIndex = bishopBitboardCopy.PopLeastSignificantBit();
            (int x, int y) = Board.ConvertSquareIndexToCoord(squareIndex);
            if (x - 1 >= 0 && y - 1 >= 0) {
                diagonalSquareMask.Or(squareIndex + CompassDirections.BottomLeft);
            }
            if (x + 1 < Board.dimensions && y - 1 >= 0) {
                diagonalSquareMask.Or(squareIndex + CompassDirections.BottomRight);
            }
            if (x - 1 >= 0 && y + 1 < Board.dimensions) {
                diagonalSquareMask.Or(squareIndex + CompassDirections.TopLeft);
            }
            if (x + 1 < Board.dimensions && y + 1 < Board.dimensions) {
                diagonalSquareMask.Or(squareIndex + CompassDirections.TopRight);
            }
            
            if (allPawnsBitboard.ContainsAny(diagonalSquareMask)) {
                score -= pawnOnAdjacentSquarePenalty;
            }
        }
        return score;
    }
    
    private int GetRookScore(int numRooksOnFile, int numPawnsOnFile) {
        int score = 0;
                
        // if there are no pawns on the file that the rook's on then add a reward
        if (numPawnsOnFile == 0) {
            int rooksOnFileWithNoPawnsReward = 10;
            score += rooksOnFileWithNoPawnsReward;
        }
        // add a reward for two rooks on the same file
        if (numRooksOnFile >= 2) {
            int sameFileRooksReward = 15;
            score += sameFileRooksReward;
        }        
        
        return score;
    }
}